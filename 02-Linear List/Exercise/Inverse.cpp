#include "Inverse.h"

using namespace std;

/*
 * 设计一个算法，将链表中所有节点的链接方向“原地”逆转，
 * 即要求仅利用原表的存储空间，换句话说，要求算法的空间复杂度为O(1)
*/

// 逆转链表
// 逆置带头结点的单链表L

void Inverse(LinkList &L) {
    LNode *p = L->next;                // p指向首元结点
    L->next = nullptr;                 // 头结点的指针域置为空

    while (p != nullptr)               // 遍历链表，如果下一个结点存在
    {
        LNode *q = p->next;            // q指向*p的后继
        p->next = L->next;
        L->next = p;                   // *p插入在头结点之后
        p = q;
    }
}

/*
 * 此题的关键点在于：不能开辟新的空间，只能改变指针的指向。因此，可以考虑逐个摘取结
 * 点，利用前插法创建链表的思想，将结点依次插到头结点的后面。因为先插入的结点为表尾，
 * 后插入的结点为表头，即可实现链表的逆转。
 */

/*
 * 算法思想是：利用原有的头结点 L, p为工作指针，初始时p指向首元结点。
 * 因为摘取的结点依次向前插入，为确保链表尾部为空，初始时应将头结点的指针域置为空。
 * 然后从前向后遍历链表，依次摘取结点，在摘取结点前需要用指针q记录后继结点，
 * 以防止链接后丢失后继结点，之后将摘取的结点插入到头结点的后面，最后p指向新的待处理的结点(p=q)
 */